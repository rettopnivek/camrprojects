% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R04-Data_wrangling.R
\name{camr_match_and_assign}
\alias{camr_match_and_assign}
\title{Assign New Values Based on Partial or Exact Matching}
\usage{
camr_match_and_assign(
  x,
  values,
  new_values = NULL,
  type = "exact",
  default = NA,
  replace_if = NULL
)
}
\arguments{
\item{x}{Either (a) a vector of values to match over, or
(b) a data frame with columns to match over.}

\item{values}{Either (a) a vector of values to match against,
or (b) a named list with values to match against. If
matching over multiple columns in a data frame, the
names for the elements of \code{values} must equal the
column names to match against. Optionally, the user
can also include an element named \code{new_values}.}

\item{new_values}{A vector of new values to assign based on
matches to elements from \code{values} (vector must be
of equivalent length to \code{values} or the elements of \code{values}).
Note if this argument is not supplied, then the argument
\code{values} must contain an element \code{new_values}.}

\item{type}{The type of matching, either 'exact' (cases for
\code{x} and \code{values} must match exactly), 'partial'
(cases for \code{x} must contain \code{values} in some form),
'greater than' (lower boundary > \code{x} \eqn{\leq} upper boundary) or
'less than' (lower boundary \eqn{\geq} \code{x} < upper boundary).
'partial' or 'exact'
(uses \code{grepl} or \verb{\\\%in\\\%}, respectively).}

\item{default}{Either a single value to assign in the absence of
a match, or a vector equivalent in length to \code{x}.}

\item{replace_if}{An optional vector specifying the subset of
default values when it is appropriate to assign new values.}
}
\value{
A new vector of equivalent length to \code{x}, with
values assigned based on successful matches.
}
\description{
A flexible function for matching old values and assigning
new values based on matches. Can also assign new values
based on whether old values fall within a range or interval
of values.
}
\examples{
# Replace letters with numbers
x <- rep( c("A", "B", "C" ), each = 2 )
camr_match_and_assign(
x,
  c( "A", "B", "C" ),
  new_values = 1:3
)

# Alternative formats for input

# As single list with both old and new values
camr_match_and_assign(
  x,
  list( x = c( "A", "B", "C" ), new_values = 1:3 )
)

# Converting matrix to data frame
camr_match_and_assign(
  x,
  rbind(
    c( "A", "1" ),
    c( "B", "2" ),
    c( "C", "3" )
  ) |> data.frame() |> setNames( c("x", "new_values" ) )
)

# Can restrict subset of entries
# over which replacement occurs;
# replace odd-numbered rows
camr_match_and_assign(
  x,
  c( "A", "B", "C" ),
  new_values = 1:3,
  default = x, # Can pass vector as default
  replace_if = seq_along( x ) \%in\% c( 1, 3, 5 )
)

# Can base on partial matching
x <- rep( c("AD", "BE", "CF" ), each = 2 )
camr_match_and_assign(
  x,
  c( "A", "B", "C" ),
  new_values = 1:3,
  type = 'partial'
)

# Can match over range or interval of values
set.seed( 112 )
x <- rnorm( 10 )
camr_match_and_assign(
  x,
  list(
    lower = c(    -Inf,  -1,    1 ),
    upper = c(      -1,   1,  Inf ),
    new_values = c( "A", "B", "C" )
  ),
  new_values = c( "A", "B", "C" ),
  type = 'greater than'
)

}
\author{
Kevin Potter
}
