% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/S01-General_purpose_functions.R
\name{extract_unique_value}
\alias{extract_unique_value}
\title{Extract Unique Values From Data Frames or Lists}
\usage{
extract_unique_value(
  x,
  variable_names,
  entries,
  default = "",
  missing = c(""),
  reference = NULL,
  check_for_multiple = TRUE,
  allow_multiple = FALSE
)
}
\arguments{
\item{x}{A data frame or a list of variables with matching lengths.}

\item{variable_names}{A vector of variables names to loop over when
attempting to isolate the unique value.}

\item{entries}{A logical vector, \code{TRUE} for rows to search for
the unique value and \code{FALSE} otherwise.}

\item{default}{The default output to return if no unique values can
be found.}

\item{missing}{A vector of values to treat as missing and exclude
when searching for the unique value.}

\item{reference}{An optional character string giving the variable
name in \code{x} to use when printing warnings in the case of
multiple values being found. Defaults to the first variable
in \code{x}.}

\item{check_for_multiple}{Logical; if \code{TRUE} will check if
more than one value was found in the subset of rows to consider
and display a warning message with details if this occurs.}

\item{allow_multiple}{Logical; if \code{TRUE} will allow multiple
return values. By default, it does not override
\code{check_for_multiple}, so remember to change this
if applicable.}
}
\value{
A single value.
}
\description{
A function that will search over a subset of rows in a data frame
(or a list structured like a data frame) and extract a unique
value after excluding missing or irrelevant data.
}
\examples{
# Create example data frame
# Create three 'ID' levels
df <- data.frame( ID = rep( 1:3, each = 3 ) )
# Create an age variable, but assume entered
# over two different variables with several
# missing values
df$Age_session_1 <- NA; df$Age_session_1[c(1,4)] = c(25,20)
# Create a status variable, but assume multiple
# indicators for missing data
df$Status <- c( 'No entry', 'Good', 'Poor',
                'No entry', 'N/A', 'Good',
                'No entry', 'Poor', 'N/A' )

# - Extract unique value for age for two different
#   variables per levels of 'ID', with user-defined
#   value for missing cases
# Loop over levels for 'ID'
for ( id in 1:3 ) {
  val <- extract_unique_value(
    x = df,
    variable_names = c( 'Age_session_1', 'Age_session_2' ),
    entries = df$ID == id,
    # Specify default value when no values found
    default = 'Missing'
  )
  # Display results
  cat( paste0( 'ID: ', id, '; Age = ', val, '\n' ) )
}

# - Extract unique values for status given
#   multiple types of missing data indicators
# - Also display warning for case where there
#   were multiple non-missing values
# Traverse levels for 'ID' via the 'sapply' function
res <- sapply( 1:3, function( id ) {
  val <- extract_unique_value(
    x = df,
    variable_names = 'Status',
    entries = df$ID == id,
    # Deal with multiple indicators for missing data
    missing = c( 'No entry', 'N/A' ),
    # Specify reference for warnings
    reference = 'ID'
  )
  # Save results
  paste0( 'ID: ', id, '; Status = ', val, '\n' )
} )
# Display results
cat( res )

}
\author{
Kevin Potter, William Schmitt
}
